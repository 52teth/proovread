#!/usr/bin/env perl

##------------------------------------------------------------------------##
# LICENCE
#
#
# $Id: sam2cns 134 2013-05-21 14:24:48Z s187512 $
#
##------------------------------------------------------------------------##

use warnings;
use strict;

use Pod::Usage;
use Getopt::Long;

use FindBin qw($RealBin);
use lib "$RealBin/../lib/";

use List::Util;

use Verbose;
use Verbose::ProgressBar;

use Sam::Parser;
use Sam::Alignment ':flags';
use Sam::Seq 0.10;

use Fasta::Parser;
use Fasta::Seq;

use Fastq::Parser;
use Fastq::Seq 0.08;

use constant {
	OFFSET => 0,
	LENGTH => 1,
};

our $VERSION  = '0.06';




=head1 NAME

sam2cns

=cut

=head1 DESCRIPTION

Compute consensus sequences based on SAM file.

=head1 SYNOPSIS

  sam2cns <OPTIONS>

=cut

=head1 CHANGELOG

=head2 0.06

=over

=item [Feature] C<< lcr-end-ratio >> to control end mask/unmask behaviour.

=item [Feature] Improved masking, ends are either unmasked or masked to the
 last nucleotide if they are too short.

=item [Feature] C<< --mask-weak-reads/--ignore-weak-reads >> to handle 
 bad reads and contaminations more efficiently

=back

=head2 0.05

=over

=item [BugFix] Only test C<< --max-reads >> if actually set.

=item [BugFix] C<< --min-lcr-length >> defaults to 120 instead of undef.

=item [BugFix] Do not add header to chimera file to make its concatenable.

=item [Feature] sam2cns uses the compressed cigar string from 
 C<< Sam::Seq->consensus >> to exactly project the chimera breakpoints from
 the reference coordinates onto the corrected sequence. These coordinates
 are reported to the chimera coords tsv.

=back

=head2 0.04

=over

=item [Change] start and end are only unmasked if the missing part is long
 enough.

=item [Feature] prevent read start/end masking within C<< --min-lcr-length >>

=item [Feature] C<< --min-lcr-length >> controls the minimum number of 
 unmasked nts between hcrs. 

=back

=head2 0.03

=over

=item [Feature] <--append> to add output to already existing file.

=item [Feature] Reference is optional, consensus from SAM only is possible.

=item [Feature] <--ignore-hcr> parameter to toggle HCR evalutation 
 consensus calls.

=item [Change] Removed C<--sticky-end-length> and  C<--hcr-mask-length> 
 parameter from command line options. Are now set via config

=item [Feature] Added <--cfg> to read from custom config

=item [Feature] Reads core config

=item [Change] Uses C<<$FindBin::RealBin>> instead of C<<$FindBin::Bin>>

=back

=head2 0.02

=over

=item [Renaming] C<$Version> to C<$VERSION>. 

=item [Feature] Added C<$REVISION>.

=item [Change] Requires Fastq::Seq 0.08, C<< fq->clone >> to C<< fq->new >>.

=item [Feature] Added C<--sticky-end-length> parameter.

=back

=head2 0.01

Initial script.

=cut



##------------------------------------------------------------------------##

# load core defaults
my $cfg_core_file = "$RealBin/../proovread.cfg"; 
my %cfg = do $cfg_core_file;

# custom config
my $cfg;
for(my $i=0; $i<@ARGV; $i++){
	if($ARGV[$i] =~ /-c$|--cfg$/){
		$cfg = $ARGV[$i+1];
		%cfg = (%cfg, do "$cfg"); 
		last;
	}
}

my %opt;

=head1 OPTIONS

=cut

=over 12

=cut

=item --cfg=<STRING>

Config file.

=cut 

$opt{'cfg=s'} = \$cfg;

=item --prefix=<STRING>

Prefix for output files.

=cut 

$opt{'prefix=s'} = \(my $opt_pre = '');

=item --sam=<PATHNAME>

A SAM file, sorted by reference, from which a consensus sequence for each reference sequence
 is to be calculated.

=cut

$opt{'sam=s'} = \(my $opt_sam_file);

=item [--sam-offset=<INT>]

A byte offset at which to start running through the --sam-file.

=cut

$opt{'sam-offset=i'} = \(my $opt_sam_offset);

=item [--ref=<PATHNAME>]

Reference sequences in FASTA or FASTQ format. If FASTQ is provided, detects 
 HCR tags in header description and inlcudes corresponding sequence 
 information in the consensus computation.

=cut

$opt{'ref=s'} = \(my $opt_ref_pat);

=item [--ref-offset=<INT>]

A byte offset at which to start running through the --ref-in file.

=cut

$opt{'ref-offset=i'} = \(my $opt_ref_offset);

=item [--max-reads=<INT>] [0]

Maximum number of reads to correct. Default OFF.

=cut

$opt{'max-reads=s'} = \(my $opt_max_reads = 0);

=item [--coverage=<INT>] [50]

Estimated coverage.

=cut

$opt{'coverage=s'} = \(my $opt_cov = 50);

=item [--qv-offset=<INT>] [33]

Quality offset.

=cut

$opt{'qv-offset=s'} = \(my $opt_qv_offset = 33);

=item [--ignore-hcr] [OFF]

Boolean. Do not parse and use HCRs from reference file in consensus calls.

=cut

$opt{'ignore-hcr'} = \(my $opt_ignore_hcr);

=item [--[no]detect-chimera] [OFF]

Boolean. Dectect, tag, and if possible resolve chimeric sequences.

=cut

$opt{'detect-chimera!'} = \(my $opt_detect_chimera);

=item [--append] [OFF]

Append output if output file already exists

=cut

$opt{'append!'} = \(my $opt_append);

=item [--min-lcr-length=<INT>] [120]

Minimum length of unmasked nts between hcrs

=cut

$opt{'--min-lcr-length=i'} = \(my $lcr_min_length = 120);

=item [--min-lcr-end-ratio=<FLOAT>] [0.5]

End mask/unmasked threshold. Read ends are either masked completely or 
 unmasked to --min-lcr-length to allow new mappings. The value specifies the
 proportions of --min-lcr-length required to unmask the end.

=cut

$opt{'--lcr-end-ratio=s'} = \(my $lcr_end_ratio = 0.5);

=item [--min-hcr-length=<INT>] [0]

Minimum length of masked nts in hcrs

=cut

$opt{'--min-hcr-length=i'} = \(my $opt_hcr_mask_length = $cfg{'hcr-mask-length'});

=item [--max-ins-length=<INT>] [4]

Maximum allowed length for inserts.

=cut

$opt{'--max-ins-length=i'} = \(my $opt_max_ins_length = 4);

=item [--mask-weak-reads=<INT>] [20]

=cut

$opt{'--mask-weak-reads=i'} = \(my $opt_mask_weak_reads = 20);

=item [--ignore-weak-reads=<INT>] [20]

Simple do not generate consensus for weakly supported reads, output them 
 unprocessed.

=cut

$opt{'--ignore-weak-reads=i'} = \(my $opt_ignore_weak_reads = 20);


$opt{'--chimera-min-score'} = \(my $opt_chimera_min_score = 0);

=back

=cut







##------------------------------------------------------------------------##

=head1 MAIN

=cut

GetOptions(%opt) or pod2usage(1);
$opt_sam_file || pod2usage(msg => 'SAM file required');


my $v = Verbose->new();

# init sam parser
my $sp = Sam::Parser->new(
	file => $opt_sam_file,
);

my $opt_hcr_sticky_length = 0;
if($opt_hcr_mask_length){
	$opt_hcr_sticky_length = $cfg{'hcr-sticky-length'};
	$v->exit('--hcr-mask-length needs to be at least twice as great as hcr-sticky-length') if ($opt_hcr_sticky_length*2 >= $opt_hcr_mask_length);
}

Sam::Seq->Trim($cfg{'sr-trim'});
Sam::Seq->InDelTaboo($cfg{'sr-indel-taboo'});
Sam::Seq->MaxCoverage($opt_cov);
Sam::Seq->BinSize($cfg{'bin-size'});
Sam::Seq->MaxInsLength($opt_max_ins_length);

Fastq::Seq->Qual_lcs_range(5, 40, $opt_qv_offset);  
## 80 chars are cutoff at each side to keep overlaps => min length 160, better 200
Fastq::Seq->Qual_lcs_min_length($opt_hcr_mask_length + (2 * $opt_hcr_sticky_length)); 

# qual window
Fastq::Seq->Qual_window_min(3);  


# use glob, to allow glob pattern instead of full filename (fa/fq is decided by parser)
my $opt_ref_file;
my $rpr;

if($opt_ref_pat){
	($opt_ref_file) = glob($opt_ref_pat);
	$v->exit("Reference file not found ($opt_ref_pat)") unless $opt_ref_file;
	# init fastq/fasta parser
	$rpr = Fastq::Parser->new(file => $opt_ref_file)->check_format;
	if($rpr){
		my $po = $rpr->guess_phred_offset();
		$v->exit("Detected [$po] and specified [$opt_qv_offset] phred offsets differ!") if defined ($opt_qv_offset) && defined ($po) && $po != $opt_qv_offset;
		$po = $po || $opt_qv_offset;
		$v->exit("Cannot guess phred offset from provided reference file, please specify --qv-offset")
			unless $po;
		$rpr->phred_offset($po);
		
	}else{
		$rpr = Fasta::Parser->new(file => $opt_ref_file)->check_format;
		unless ($opt_ignore_hcr){
			$opt_ignore_hcr++;
			# $v->verbose('Cannot restore HCR information from FASTA, --ignore-hcr set to TRUE');
		}
	}
	$v->exit("Unknown format of reference file: $opt_ref_file") unless $rpr;
}

# output files
my $fq_out =  $opt_pre.'.fq';
my $fam_out = $opt_pre.'.masked.fa';
my $fqi_out = $opt_pre.'.ignored.tsv'; # ignored
my $fc_out =  $opt_pre.'.chim.tsv'; # chimera annot

my $mode = $opt_append ? ">>" : ">";

my $fqh;
open($fqh, $mode, $fq_out) || $v->exit("Can't open output read file: '$fq_out'");
my $fmh;
open($fmh, $mode, $fam_out) || $v->exit("Can't open output read file: '$fam_out'");
my $fih;
open($fih, $mode, $fqi_out) || $v->exit("Can't open output read file: '$fqi_out'");
my $fch;
open($fch, $mode, $fc_out) || $v->exit("Can't open output read file: '$fc_out'");
#print $fch (join("\t", '#id', qw(from to score)),"\n") if ! -s $fch;


my %LR;


# ref
if($rpr){ # read fasta to get ref id, length and seq
	$rpr->seek($opt_ref_offset) if $opt_ref_offset;
	my $ref_c = 0;
	while(my $ref = $rpr->next_seq()){
		$LR{$ref->id} = Sam::Seq->new(
			ref => $ref,
			len => length($ref->seq),
			id => $ref->id
		);
		last if ++$ref_c >= $opt_max_reads;
	}
}else{# read the sam header to get ref ids and length
	while(my %h = $sp->next_header_line('SQ')){
		$LR{$h{'SN'}} = Sam::Seq->new(
			id => $h{SN}, 
			len => $h{LN},
		);
	}
}



# read sam
my @LR_IDS;

$sp->seek($opt_sam_offset) if $opt_sam_offset;
# w/ reference
if($rpr){
	while(my $aln = $sp->next_aln()){
		# try to add aln, if sufficient score, add to temporary sam file
		last unless exists $LR{$aln->rname};
		$opt_detect_chimera		# binning required for chimera detection
			? $LR{$aln->rname}->add_aln_by_score($aln)
			: $LR{$aln->rname}->add_aln($aln);
	}
# w/o reference
}else{
	my $ref_seen = 0; # since we read the entire header to %LR, we need to count ref seqs
	my $ref_id = '';
	while(my $aln = $sp->next_aln()){
		# try to add aln, if sufficient score, add to temporary sam file
		unless ($ref_id eq $aln->rname){
			$ref_id = $aln->rname;
			push @LR_IDS, $ref_id;
			$ref_seen++;
			last if $opt_max_reads && $ref_seen > $opt_max_reads;
		}
		$opt_detect_chimera		# binning required for chimera detection
			? $LR{$aln->rname}->add_aln_by_score($aln)
			: $LR{$aln->rname}->add_aln($aln);
	}
}

# calculate consensus
unless(@LR_IDS){
	@LR_IDS = sort byfile keys %LR 
}

foreach my $pb_id(@LR_IDS){
	my @hcrs = ();
	
	if($rpr && ! $opt_ignore_hcr){
		if(my $hcrs = $LR{$pb_id}{ref}->desc){
			while($hcrs =~ /HCR\d+:(\d+),(\d+)/g){
				push @hcrs, [$1, $2];
			}
		};
	}
	
	if(! @hcrs){
		if(
			($opt_mask_weak_reads && $LR{$pb_id}->{_aln_idc} < $opt_mask_weak_reads)
			|| ($opt_ignore_weak_reads && $LR{$pb_id}->{_aln_idc} < $opt_ignore_weak_reads)
		){
			my $seq = $LR{$pb_id}->{ref};
			unless (ref $seq eq "Fastq::Seq"){
				$seq = Fastq::Seq->new(
					substr($seq->seq_head, 1),
					$seq->seq,
					'+',
					'!' x length ($seq->seq),
					phred_offset => 33,
				);
			}else{
				$seq->qual('!' x length ($seq->seq)),
			}
			
			
			unless ($seq->desc() =~ /IGNORED:low_support/){
				$seq->desc_append("IGNORED:low support"); 
				# write to ignored fastq
				print $fih $seq->id,"\n";
			}
			
			# write unprocessed fastq
			print $fqh "$seq";
			
			# write masked/unprocessed fasta
			printf $fmh (">%s\n%s\n", substr($seq->seq_head, 1), 
				$opt_mask_weak_reads ? "N" x length($seq->seq) : $seq->seq);

			next;
		}
	}
	
	my $con = $LR{$pb_id}->consensus(@hcrs);
	
	# chimera
	if($opt_detect_chimera){
		my @coords = $LR{$pb_id}->chimera(); 
		
		#-----------------------------------------------------------------#
		#my %cigar = (M=>0, I=>0, D=>0);
		#while($con->{cigar} =~ m/(\d+)(\w)/g){
		#	$cigar{$2}+=$1;
		#}
		#my $pred_len = $cigar{M}+$cigar{D};
		#my $corr_len = length($LR{$pb_id}{ref}->seq)+$cigar{D}-$cigar{I};
		#printf("%s\t%s\t%s\n", length($con->seq), $pred_len, $corr_len) if $pred_len !=  $corr_len or length($con->seq) != $corr_len;
		#
		#-----------------------------------------------------------------#
		
		
		if(@coords){
			my $i;
			my %cigar = (M=>0, I=>0, D=>0);
			for($i=0; $i<@coords; $i++){
				
				my $fr = $coords[$i]{col_range}[0];
				my $to = $coords[$i]{col_range}[1];
				my $sc = $coords[$i]{score};
				
				# use cigar to compute correct location of chimera coords on corrected seq.
				# -I, +D
				# get read cigar, eg 80M2D3M1IM4
				# /g remembers position even between multiple calls to while on same cigar
				# hence we can just always add to %cigar outside the for loop
				while($con->{cigar} =~ m/(\d+)(\w)/g && ($cigar{M}+$cigar{I} < $fr)){ 
					$cigar{$2}+=$1;
				}
				
				my $pos_corr = $cigar{D}-$cigar{I}; # corrected string has additional nucs
					# at D's and has lost nucs at I's
				$fr+=$pos_corr;
				$to+=$pos_corr;

				if($to > length($con->seq)){
					use Data::Dumper;
					die "Chimera Breakpoint outside of sequence", Dumper({
						cigar => \%cigar,
						poscorr => $pos_corr,
						conlen => length ($con->seq),
						concigar => $con->{cigar},
						reflen => length ($LR{$pb_id}{ref}->seq),
						coords => $coords[$i],
					});
				};

				printf $fch("%s\t%d\t%d\t%s\n", $pb_id, $fr, $to, $sc);
			}
		}
	}
	
	# undef state matrix to make memory availabe again
	$LR{$pb_id}{_state_matrix} = {}; 

	if($opt_hcr_mask_length){
		# $hcrs[$i][0] == $hcrs[$i][OFFSET] := offset
		# $hcrs[$i][1] == $hcrs[$i][LENGTH] := length
		
		# clone
		my $con_mask = $con->new;
		# compute high coverage regions 
		my @hcrs = ($con_mask->qual_lcs());
		if(@hcrs){
			my $i = 0;
			# create a description string of hcrs in seq
			my @hcrs_string = map{"HCR".++$i.":".$_->[OFFSET].','.$_->[LENGTH]}@hcrs;
			# add desc to header
			$con->{seq_head}.= ' '.join(" ", @hcrs_string);
			# mask hcrs minus overlap ends
			# NOTE: this actually changes the values @hcrs!
			
			# add sticky ends
			foreach(@hcrs){
				$_->[OFFSET]+=$opt_hcr_sticky_length; 
				$_->[LENGTH]-=($opt_hcr_sticky_length * 2);
			}			
			
			# mask/unmask start
			my $lcr_start_missing = $lcr_min_length - $hcrs[0][OFFSET];
			# Consider starts shorter then lcr_min_length
			if($lcr_start_missing > 0){
				# unmask start if its long enough to be worth it: missing < 50% lcr_min_length
				if( $lcr_start_missing < $lcr_end_ratio * $lcr_min_length ){ 
					#$v->hline;
					#$v->verbose('first hcr to close to start '.$lcr_start_missing);
					# if OFFSET is adjusted, LENGTH always needs to be adjusted
					#  as well or the HCR is just shifted
					# adjust length, check for hcr_min_length
					if( ($hcrs[0][LENGTH] -= $lcr_start_missing) < $opt_hcr_mask_length){
						#$v->verbose('first hcr to short: '.$hcrs[0][LENGTH]);
						shift @hcrs; # remove first hcr if it becomes to short after trimming
					}else{
						#$v->verbose('first hcr trimmed');
						$hcrs[0][OFFSET] += $lcr_start_missing;
					}
				}else{# mask start completely
					$hcrs[0][LENGTH] += $hcrs[0][OFFSET];
					$hcrs[0][OFFSET] = 0;
				}
			} 
			
			# mask/unmask end
			if( scalar @hcrs){ # check if there are HCRs, might be trimmed by first
				my $lcr_end_missing = $lcr_min_length - (length($con_mask->seq) - ($hcrs[$#hcrs][OFFSET] + $hcrs[$#hcrs][LENGTH]));
				# check if it is to close to the end
				if($lcr_end_missing  > 0){
					if($lcr_end_missing < $lcr_end_ratio * $lcr_min_length ){
						#$v->verbose('last hcr to close to end '.$lcr_end_missing);
						# shorten last hcr and check its length
						if( ($hcrs[$#hcrs][LENGTH] -= $lcr_end_missing) < $opt_hcr_mask_length){
							#$v->verbose('last hcr to short');
							pop @hcrs; # remove first hcr if it becomes to short after trimming
						}
					}else{# extend hcr to end of seq
						$hcrs[$#hcrs][LENGTH] += $lcr_min_length - $lcr_end_missing
					}
				}
			} 
			
			# make sure unmask regions are large enough to map more reads
			# do not process first/last
			my @remove_hcrs;
			if(@hcrs > 2){
				for($i=2; $i < @hcrs-1; $i++){
					my $start_b = $hcrs[$i][OFFSET];
					my $end_a = $hcrs[$i-1][OFFSET] + $hcrs[$i-1][LENGTH];
					# lcr to short
					if( (my $lcr_min_missing = $lcr_min_length - ($start_b - $end_a)) > 0 ){
						#$v->verbose('lcr missing '.$lcr_min_missing.' between h'.($i-1).' and h'.($i));
						
						#  what if: move forward start_b by half the missing nts	
						my $el = $hcrs[$i][LENGTH] - $lcr_min_missing/2;
						if($el < $opt_hcr_mask_length){
							#$v->verbose('h'.($i).' to short: '."$el < $opt_hcr_mask_length");	
							push @remove_hcrs, $i;
							$i++; # skip one
							next; # dont change previous hcr
						}
						
						# what if: move back end_e by half the missing nts
						my $sl = $hcrs[$i-1][LENGTH] - $lcr_min_missing/2;
						if($sl < $opt_hcr_mask_length){
							#$v->verbose('h'.($i-1).' to short: '."$sl < $opt_hcr_mask_length");	
							push @remove_hcrs, $i-1;
							next; # dont change next hcr
						}

						# move forward start_b by half the missing nts
						$hcrs[$i][OFFSET] += $lcr_min_missing/2;
						$hcrs[$i][LENGTH] -= $lcr_min_missing/2;
						
						# move back end_e by half the missing nts
						$hcrs[$i-1][LENGTH] -= $lcr_min_missing/2;
						#$v->verbose('hcrs trimmed');	
					}
				}
			}
			
			# remove hcrs which became to small after masking
			# reverse or else we mess up 
			# incex if stuff at the beginning gets removed
			foreach (reverse @remove_hcrs){ 
				#$v->verbose('removing h'.$_);	
				splice @hcrs, $_, 1;
			}

			#$v->hline;

			$con_mask->mask_seq(@hcrs) if @hcrs;
		}
	
		# write (masked) FASTA for next pass
		printf $fmh (">%s\n%s\n", substr($con->seq_head, 1), $con_mask->seq);
	}
	
	# write current fastq
	print $fqh "$con";
	
}



=head2 byfile

Sort function for "natural" filesorting, descending.

=cut

sub byfile {
  my @a = split /(\d+)/, $a;
  my @b = split /(\d+)/, $b;
  my $M = @a > @b ? @a : @b;
  my $res = 0;
  for (my $i = 0; $i < $M; $i++) {
    return -1 if ! defined $a[$i];
    return 1 if  ! defined $b[$i];
    if ($a[$i] =~ /\d/) {
      $res = $a[$i] <=> $b[$i];
    } else {
      $res = $a[$i] cmp $b[$i];
    }
    last if $res;
  }
  $res;
}

=head1 AUTHORS

Thomas Hackl S<thomas.hackl@uni-wuerzburg.de>

=cut
