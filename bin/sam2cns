#!/usr/bin/env perl

##------------------------------------------------------------------------##
# LICENCE
#
#
# $Id$
#
##------------------------------------------------------------------------##

use warnings;
use strict;

use Pod::Usage;
use Getopt::Long;

use FindBin qw($RealBin);
use lib "$RealBin/../lib/";

use Verbose;
use Verbose::ProgressBar;

use Sam::Parser;
use Sam::Alignment ':flags';
use Sam::Seq;

use Fasta::Parser;
use Fasta::Seq;

use Fastq::Parser;
use Fastq::Seq 0.08;

our $VERSION  = '0.03';
our ($REVISION) = '$Revision$' =~ /(\d+)/;
our ($MODIFIED) = '$Date$' =~ /Date: (\S+\s\S+)/;


=head1 NAME

sam2cns

=cut

=head1 DESCRIPTION

Compute consensus sequences based on SAM file.

=head1 SYNOPSIS

  sam2cns <OPTIONS>

=cut

=head1 CHANGELOG

=head2 0.03

=over

=item [Feature] <--append> to add output to already existing file.

=item [Feature] Reference is optional, consensus from SAM only is possible.

=item [Feature] <--ignore-hcr> parameter to toggle HCR evalutation 
 consensus calls.

=item [Change] Removed C<--sticky-end-length> and  C<--hcr-mask-length> 
 parameter from command line options. Are now set via config

=item [Feature] Added <--cfg> to read from custom config

=item [Feature] Reads core config

=item [Change] Uses C<<$FindBin::RealBin>> instead of C<<$FindBin::Bin>>

=back

=head2 0.02

=over

=item [Renaming] C<$Version> to C<$VERSION>. 

=item [Feature] Added C<$REVISION>.

=item [Change] Requires Fastq::Seq 0.08, C<< fq->clone >> to C<< fq->new >>.

=item [Feature] Added C<--sticky-end-length> parameter.

=back

=head2 0.01

Initial script.

=cut



##------------------------------------------------------------------------##

# load core defaults
my $cfg_core_file = "$RealBin/../proovread.cfg"; 
my %cfg = do $cfg_core_file;

# custom config
my $cfg;
for(my $i=0; $i<@ARGV; $i++){
	if($ARGV[$i] =~ /-c$|--cfg$/){
		$cfg = $ARGV[$i+1];
		%cfg = (%cfg, do "$cfg"); 
		last;
	}
}

my %opt;

=head1 OPTIONS

=cut

=over 12

=cut

=item --cfg=<STRING>

Config file.

=cut 

$opt{'cfg=s'} = \$cfg;


=item --prefix=<STRING>

Prefix for output files.

=cut 

$opt{'prefix=s'} = \(my $opt_pre = '');

=item --sam=<PATHNAME>

A SAM file, sorted by reference, from which a consensus sequence for each reference sequence
 is to be calculated.

=cut

$opt{'sam=s'} = \(my $opt_sam_file);

=item [--sam-offset=<INT>]

A byte offset at which to start running through the --sam-file.

=cut

$opt{'sam-offset=i'} = \(my $opt_sam_offset);

=item [--ref=<PATHNAME>]

Reference sequences in FASTA or FASTQ format. If FASTQ is provided, detects 
 HCR tags in header description and inlcudes corresponding sequence 
 information in the consensus computation.

=cut

$opt{'ref=s'} = \(my $opt_ref_pat);

=item [--ref-offset=<INT>]

A byte offset at which to start running through the --ref-in file.

=cut

$opt{'ref-offset=i'} = \(my $opt_ref_offset);

=item [--max-reads=<INT>] [0]

Maximum number of reads to correct. Default OFF.

=cut

$opt{'max-reads=s'} = \(my $opt_max_reads = 0);

=item [--coverage=<INT>] [50]

Estimated coverage.

=cut

$opt{'coverage=s'} = \(my $opt_cov = 50);

=item [--qv-offset=<INT>] [33]

Quality offset.

=cut

$opt{'qv-offset=s'} = \(my $opt_qv_offset = 33);

=item [--ignore-hcr] [OFF]

Boolean. Do not parse and use HCRs from reference file in consensus calls.

=cut

$opt{'ignore-hcr!'} = \(my $opt_ignore_hcr);

=back

=item [--append] [OFF]

Append output if output file already exists

=cut

$opt{'append!'} = \(my $opt_append);

=back



=cut







##------------------------------------------------------------------------##

=head1 MAIN

=cut

GetOptions(%opt) or pod2usage(1);
$opt_sam_file || pod2usage(msg => 'SAM file required');


my $v = Verbose->new();

# init sam parser
my $sp = Sam::Parser->new(
	file => $opt_sam_file,
);

my $opt_hcr_mask_length = $cfg{'hcr-mask-length'};
my $opt_hcr_sticky_length = $cfg{'hcr-sticky-length'};

Sam::Seq->Trim($cfg{'sr-trim'});
Sam::Seq->InDelTaboo($cfg{'sr-indel-taboo'});
Sam::Seq->MaxCoverage($opt_cov);
Sam::Seq->BinSize($cfg{'bin-size'});


# qual_lcs is used on cov seq to mask high cov regions, min cov 10

##########################################
# TODO: mask hcr based on phreds
##########################################

Fastq::Seq->Qual_lcs_range(10, 40, $opt_qv_offset);  
# 80 chars are cutoff at each side to keep overlaps => min length 160, better 200
Fastq::Seq->Qual_lcs_min_length($opt_hcr_mask_length + (2 * $opt_hcr_sticky_length)); 


# use glob, to allow glob pattern instead of full filename (fa/fq is decided by parser)
my $opt_ref_file;
my $rpr;

if($opt_ref_pat){
	($opt_ref_file) = glob($opt_ref_pat);
	$v->exit("Reference file not found ($opt_ref_pat)") unless $opt_ref_file;
	# init fastq/fasta parser
	$rpr = Fastq::Parser->new(file => $opt_ref_file)->check_format;
	if($rpr){
		$rpr->guess_phred_offset();
	}else{
		$rpr = Fasta::Parser->new(file => $opt_ref_file)->check_format;
	}
	$v->exit("Unknown format of reference file: $opt_ref_file") unless $rpr;
}

# output files
my $fq_out = $opt_pre.'.fq';
my $fa_out = $opt_pre.'.fa';
my $fm_out = $opt_pre.'.fm';

my $mode = $opt_append ? ">>" : ">";

my $fqh;
open($fqh, $mode, $fq_out) || $v->exit("Can't open output read file: '$fq_out'");
my $fah;
open($fah, $mode, $fa_out) || $v->exit("Can't open output read file: '$fa_out'");
my $fmh;
open($fmh, $mode, $fm_out) || $v->exit("Can't open output read file: '$fm_out'");



my %PB;

# ref
if($rpr){ # read fasta to get ref id, length and seq
	$rpr->seek($opt_ref_offset) if $opt_ref_offset;
	my $ref_c = 0;
	while(my $ref = $rpr->next_seq()){
		$PB{$ref->id} = Sam::Seq->new(
			ref => $ref,
			len => length($ref->seq),
			id => $ref->id
		);
		last if ++$ref_c >= $opt_max_reads;
	}
}else{# read the sam header to get ref ids and length
	while(my %h = $sp->next_header_line('SQ')){
		$PB{$h{'SN'}} = Sam::Seq->new(
			id => $h{SN}, 
			len => $h{LN},
		);
	}
}



# read sam
my @PB_IDS;

$sp->seek($opt_sam_offset) if $opt_sam_offset;
if($rpr){
	while(my $aln = $sp->next_aln()){
		# try to add aln, if sufficient score, add to temporary sam file
		last unless exists $PB{$aln->rname};
		$PB{$aln->rname}->add_aln($aln);
	}
}else{
	my $ref_seen = 0; # since we read the entire header to %PB, we need to count ref seqs
	my $ref_id = '';
	while(my $aln = $sp->next_aln()){
		# try to add aln, if sufficient score, add to temporary sam file
		unless ($ref_id eq $aln->rname){
			$ref_id = $aln->rname;
			push @PB_IDS, $ref_id;
			$ref_seen++;
			last if $ref_seen > $opt_max_reads;
		}
		$PB{$aln->rname}->add_aln($aln);
	}
}

# calculate consensus
unless(@PB_IDS){
	@PB_IDS = sort byfile keys %PB 
}

foreach my $pb_id(@PB_IDS){
	my @hcrs = ();
	
	if($rpr && ! $opt_ignore_hcr){
		if(my $hcrs = $PB{$pb_id}{ref}->desc){
			while($hcrs =~ /HCR\d+:(\d+),(\d+)/g){
				push @hcrs, [$1, $2];
			}
		};
	}
	
	my $con = $PB{$pb_id}->consensus(@hcrs);
	# clone
	my $con_mask = $con->new;
	# undef state matrix to make memory availabe again
	$PB{$pb_id}{_state_matrix} = {}; 
	
	# use cov seq instead of qual seq in Fastq::Seq, mask based on cov
	# $con_mask->{qual} = $con_mask->{cov};

	if($opt_hcr_mask_length){
		# compute high coverage regions 
		my @hcrs = ($con_mask->qual_lcs());
		if(@hcrs){
			my $i = 0;
			# create a description string of hcrs in seq
			my @hcrs_string = map{"HCR".++$i.":".$_->[0].','.$_->[1]}@hcrs;
			# add desc to header
			$con->{seq_head}.= ' '.join(" ", @hcrs_string);
			# mask hcrs minus overlap ends
			# NOTE: this actually changes the values @hcrs!
			$con_mask->mask_seq(map{$_->[0]+=$opt_hcr_sticky_length; $_->[1]-=$opt_hcr_sticky_length; $_}@hcrs);
		}
	
		# write (masked) FASTA for next pass
		printf $fmh (">%s\n%s\n", substr($con->seq_head, 1), $con_mask->seq);
	}
	
	# write current fastq
	print $fqh $con->string;
	
	# write current fasta
	printf $fah (">%s\n%s\n", substr($con->seq_head, 1), $con->seq);
	
	
}



=head2 byfile

Sort function for "natural" filesorting, descending.

=cut

sub byfile {
  my @a = split /(\d+)/, $a;
  my @b = split /(\d+)/, $b;
  my $M = @a > @b ? @a : @b;
  my $res = 0;
  for (my $i = 0; $i < $M; $i++) {
    return -1 if ! defined $a[$i];
    return 1 if  ! defined $b[$i];
    if ($a[$i] =~ /\d/) {
      $res = $a[$i] <=> $b[$i];
    } else {
      $res = $a[$i] cmp $b[$i];
    }
    last if $res;
  }
  $res;
}

=head1 AUTHORS

Thomas Hackl S<thomas.hackl@uni-wuerzburg.de>

=cut
