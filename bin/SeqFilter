#!/usr/bin/env perl

# $Id: Verbose.pm 644 2013-01-18 16:04:44Z dumps $

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;

use FindBin qw($RealBin);
use lib "$RealBin/../lib/";

use Verbose;
use Verbose::ProgressBar;

use Fastq::Parser 0.07;
use Fastq::Seq 0.10;

use Fasta::Parser 0.06;
use Fasta::Seq 0.06;

our $VERSION = '1.00';

=head1 NAME

SeqFilter - Versatile FASTA/FASTQ sequence file analysis and modification tool.

=cut

=head1 CHANGELOG seqz (combined Fasta-/FastqFilter)

=head 1.00

=over

=item [Refactoring] Merged FastaFilter.pl and FastqFilter.pl in this one script.

=back

=head1 CHANGELOG FastqFilter

=head2 1.10

=over

=item [Feature] substring extraction and modification of sequences based
 on coordinates file.

=bach

=head2 1.03 [Thomas Hackl 2013-01-28]

=over

=item [Feature] C<--phred-transform> to switch phred offsets between 33 and 64

=item [BugFix] Did set sliding window size instead of min value.

=item [Feature] IDS can have leading '@' or '>'.

=item [Change] C<--min-length/--max-length> filter are now executed
 after any trimming stuff.

=item [Feature] Autodetect <--phred-offset>.

=item [Feature] Sliding window based C<--trim>. 

=item [Renaming] C<--slice-lcs> to C<--trim-lcs>.

=back

=over

=item 1.02 [Thomas Hackl 2012-13-09]

Bugfix. Nx computation now correctly uses total length of filtered
 output, not total length of input.

=item 1.01 [Thomas Hackl 2012-11-09]

Bugfix. Renamed C<< reads_ids >> to C<< read_ids >>.

=item 1.00 [Thomas Hackl 2012-11-08]

Major Refactoring. 

=item 0.06 [Thomas Hackl 2012-11-06]

Bugfix. --fasta now accuratly also prints the descrition of the header line.

=item 0.05 [Thomas Hackl 2012-10-02]

Added --slice_lcs

=item 0.04 [Thomas Hackl 2012-09-27]

Removed --n-content, added --base-content, which allows you to specify 
 particular bases or group of base in a "," separated list to be scanned for.

=item 0.03 [Thomas Hackl 2012-08-31]

Added --ids, --ids-exclude

=item 0.02 [Thomas Hackl 2012-08-30]

Versioned, Verbose::ProgressBar, --min-length

=cut

=head1 TODO

=over

=item paired

=back

=cut



##------------------------------------------------------------------------##

=head1 SYNOPSIS

  perl SeqFilter --in <SEQFILE> <OPTIONS> --out <OUTFILE>
  
  cat <SEQFILE> | SeqFilter <OPTIONS> --out '-' > OUTFILE

=cut

=head1 OPTIONS

=cut

=over

=cut

my %opt;

=item [--in=<FASTA/FASTQ>]

Input FASTA/FASTQ file. Default STDIN.

=cut

$opt{'in=s'} = \(my $opt_in = undef);

=item [--out=<STRING>]

Output file. Default off. Specify '-' for STDOUT.

=cut

$opt{'out=s'} = \(my $opt_out = undef);

=item [--tsv=<STRING>/'-']

Print tab separated statistics of data AFTER filtering to pathname, 
 default off, specify '-' for STDOUT, but only if '--out' is not redirected 
 to STDOUT.

Column order is: number of sequences, total length, longest, shortest, 
 Nx-values, base-contents. No header is printed, so multiple runs can 
 simply be concatenated.

=cut 

$opt{'tsv=s'} = \(my $opt_tsv = '');

=item [--ids=<FILE>/--ids='-']

Pathname to file of sequence IDs or list of IDs to be reported. Reads
 comma-separated, whitespace and newline separated lists. Specify '-' to 
 read IDs form STDIN. Leading '>' or '@' are allowed but not necessary.

=cut 

$opt{'ids=s'} = \(my $opt_ids = '');

=item [--ids-exclude]

Exclude reads specified by --ids from being reported. Default off.

=cut 

$opt{'ids-exclude'} = \(my $opt_ids_exclude = undef);

=item [--min-length=<INT>]

Minimum sequence length.

=cut

$opt{'min-length=i'} = \(my $opt_min_length = 0);

=item [--max-length=<INT>]

Maximum length for sequences to be retrieved. Default off.
 
=cut 

$opt{'max-length=i'} = \(my $opt_max_length = undef);

=item [--fasta]

FASTQ only. output FASTA format. Default FASTQ.

=cut

$opt{'fasta'} = \(my $opt_fasta = undef);

=item [--phred-offset] [auto]

FASTQ only. Phred offset for quality scores. Default auto-detect.

=cut

$opt{'phred-offset=i'} = \(my $opt_offset);

=item [--phred-transform]

FASTQ only. Transform phreds from input offset to specified C<--phred-transform> offset,
 usually 33 to 64 or wise versa.

=cut

$opt{'phred-transform'} = \(my $opt_transform);

=item [--phred-mask]

FASTQ only. Two values separated by ",", e.g "0,10" to mask all Nucleotides with
 phred below 10 with an "N".
 
NOTE: Requires C<--phred-offset>.

=cut

$opt{'phred-mask=s'} = \(my $opt_mask = undef);

=item [--trim-window=<INT1>,[<INT2>]]

FASTQ only. Trim sequences to quality >= INT1 using a sliding window of size
 INT2, default 10. The sliding window allows to have positions
 below the <--trim> cutoff provided the window mean is higher than
 INT1. It is made sure that a) positions with quality below cutoff only 
 occur within the remaining sequence, not at its start/end and b) windows
 never overlap eachother.

=cut

$opt{'trim-window=s'} = \(my $opt_trim = undef);

=item [--trim-lcs=<INT,INT,INT>]

FASTQ only. Three values separated by ",", e.g. "30,40,50" to grep all stretches
 of quality >= 30 and minimum length 50 from the sequences.
Faster than C<--trim-window> yet breaks sequences even on a single low
 quality position.

NOTE: C<--trim-lcs> and C<--trim-window> can be combined, e.g.

  --trim-lcs 5,40,100 --trim-window 10

will generate sequences with qualities of at least 5 at every position and 
 a window mean of 10.

=cut

$opt{'trim-lcs=s'} = \(my $opt_slice_lcs = undef);

=item [--substr=<FILE>]    

Pathname to a FILE containing information for subseq extraction/modification
The format is a tsv, starting with the ID of the read, followed by the substr
 values OFFSET,LENGTH,REPLACESEQ,REPLACEQUAL. The parameter usage is the 
 same as for perl builtin C<substr> function, meaning an OFFSET alone is 
 sufficient, a positive value is set from the start of the sequence, a 
 negative offset from the end, without LENGTH, the sequence is returned from
 OFFSET to its end. REPLACEMENTS are introduced at the OFFSET position, 
 if LENGTH is 0, it is a simple insertion, else a part is deleted first and
 the REPLACEMENT is then inserted. Substring extraction is of course 
 performed prior to any other trimming. To trim all reads use '*' instead
 of the read id. This command will be performed prior to any indiviual 
 substr command.

Examples:

  # trim read1 head and tail by 10
  read1   10
  # extract from read2 250 nts starting at pos 15
  read2   15   250
  # replace 3 nt by an "N"" with qual "!" (for FASTQ)
  read3   3   1   N   !
  # trim from all reads 5nts at the beginning and the end.
  *	5
  *	-5

=cut

$opt{'substr=s'} = \(my $opt_substr_file = undef);

=item [--N=<INT,INT...>]

Report Nx value (N50, N90...). Specify multiple values as comma separated
 STRING. Takes filter settings into account. Result might be ommited if to
 few sequences are retrieved. Default "50,90".

=cut 

$opt{'N=s'} = \(my $opt_N = '90,50');

=item [--base-content=<BASE(S),BASE(S),BASE(S),...>]

Count and print the relative amount of given bases. Takes a "," separated 
 list, each element of the list can be one or more bases. In the letter case
 the commulative amount of the individual bases is calculated.
 
Examples:
  --base-content=A,T,G,C,N   # content of regular bases
  --base-content=GC          # combined GC content

=cut

$opt{'base-content=s'} = \(my $opt_base_content = undef);

=item --[no]verbose

Toggle verbose, default on.

=cut 

$opt{'verbose!'} = \(my $opt_verbose = 1);

=item [--help]

Display this help

=cut

$opt{'help|?'} = \(my $opt_help);

=back

=cut



GetOptions(%opt) or pod2usage(1);
if(@ARGV && !($ARGV[0] =~ /^-/) && !$opt_in){
	$opt_in = $ARGV[0];
}

pod2usage(1) if $opt_help;
if($opt_max_length && $opt_min_length && ($opt_min_length > $opt_max_length)){
	pod2usage(exitval=>1, msg=>'min-length has to be smaller than max-length'); 
}elsif($opt_ids eq '-' && !$opt_in){
	pod2usage(exitval=>1, msg=>'Cannot read IDS and sequences from STDIN');
}
$opt_substr_file && !-e $opt_substr_file && pod2usage(exitval=>1, msg=>'Cannot find SUBSTR file: '.$opt_substr_file);


##------------------------------------------------------------------------##

=head1 MAIN

=cut

my $V = Verbose->new(
	report_level => $opt_verbose || 0,
	line_width => 80
);


##------------------------------------------------------------------------##

=head2 check input file

=cut

# Fasta parser
$V->verbose("Reading Input from ".( $opt_in ? $opt_in : "STDIN" ));

my $FP;
my $FASTQ;

if(
	$FP = Fastq::Parser->new(
		file => $opt_in, # defaults to STDIN if undef
	)->check_format
){
	$FASTQ = 1;
	$opt_offset = $FP->guess_phred_offset unless $opt_offset;
	pod2usage(msg=>'Could not guess phred offset, please specify manually', exitval => 2) 
		unless $opt_offset;
	$V->verbose('Detected FASTQ format, phred-offset '.$opt_offset);
}elsif(
	$FP = Fasta::Parser->new(
		file => $opt_in, # defaults to STDIN if undef
	)->check_format
){
	$FASTQ = 0;
	$V->verbose('Detected FASTA format');
}else{
	$V->exit($opt_in." neither FASTA nor FASTQ") unless $FP;
}


my $VPB = Verbose::ProgressBar->new(
	report_level => $opt_verbose || 0,
	size => $FP->fh()
);


# output file
my $ofh;
if($opt_out){
	if($opt_out eq '-'){
		$ofh = \*STDOUT;
	}else{
		open($ofh, ">", $opt_out) || $V->exit("Can't open output read file: '$opt_out'");
	} 
}


##------------------------------------------------------------------------##

=head2 FASTQ/FASTA parameter

=cut

my %opt_fq_only = (
	'phred-transform' => $opt_transform,
	'phred-mask' => $opt_mask,
	'trim-window' => $opt_trim,
	'trim-lcs' => $opt_slice_lcs,
);

if(!$FASTQ){
	while (my ($k,$v) = each %opt_fq_only){
		defined $v && $V->exit("$k can only be used on FASTQ data"); 
	}
}


##------------------------------------------------------------------------##

=head2 prepare som filter

=cut

my @opt_base_content = split(/\s*,\s*/, $opt_base_content) if $opt_base_content;
my @opt_N = sort{$a <=> $b}(split(/\s*,\s*/, $opt_N)) if $opt_N;
my %IDS = read_ids() if $opt_ids;
my %SUBSTR = read_substrs() if $opt_substr_file;

my $tsv;
if($opt_tsv){
	if($opt_tsv eq '-' && (!defined($opt_out) || $opt_out ne '-')){
		$tsv = \*STDOUT;
	}else{
		open($tsv, ">", $opt_tsv) || $V->exit("Can't open tsv stats file: '$opt_tsv'");
	} 
}

if($opt_mask){
	my($from, $to, $length) = split(',', $opt_mask);
	Fastq::Seq->Qual_low_range($from, $to, $opt_offset);
}

if($opt_slice_lcs){
	my($from, $to, $length) = split('\s*,\s*', $opt_slice_lcs);
	Fastq::Seq->Qual_lcs_range($from, $to, $opt_offset);
	Fastq::Seq->Qual_lcs_min_length($length);
}

if($opt_trim){
	my ($min, $wsize) = (split(',', $opt_trim), 10);
	Fastq::Seq->Qual_window_min($min);
	Fastq::Seq->Qual_window_size($wsize);
}

# TOTAL
my @total_L;
my $total_count;	# total count
my $total_length = 0;
my $total_longest = 0;
my $total_shortest = undef;
my %total_Ns;

# FILTERED
my @filtered_L; # lengths of seqs
my $filtered_length = 0;
my $filtered_longest = 0;
my $filtered_shortest = undef;
my %filtered_Ns; #Nx values
my %BCs; # base contents



##------------------------------------------------------------------------##

=head2 loop through file and apply filter

=cut

# loop through FASTQ
while (my $SEQ = $FP->next_seq()){
	$total_count++;
	$VPB->update();

	my $length = length($SEQ->seq);
	
	# TOTAL STATS		
	# store length for Nx computation
	push @total_L, $length;
	# length stuff
	$total_length+=$length;
	$total_longest = $length if $length > $total_longest;
	$total_shortest = $length if (!defined ($total_shortest) || $length < $total_shortest);
	
	
	# FILTER
	# ids
	if(keys %IDS){
		if ($opt_ids_exclude){
			next if $IDS{$SEQ->id}
		}else{
			next unless $IDS{$SEQ->id}
		}
	}
	
	my @fq = ($SEQ);

	# substr
	if($opt_substr_file && exists $SUBSTR{'*'} ){
		@fq = map{
			$_->substr_seq(@{$SUBSTR{'*'}});
		}@fq;
	}
	
	if($opt_substr_file && exists $SUBSTR{$SEQ->id} ){
		@fq = map{
			$_->substr_seq(@{$SUBSTR{$SEQ->id}});
		}@fq;
	}
	
	# slice by lcs
	if($opt_slice_lcs){ # trim lcs
		@fq = map{$_->substr_qual_lcs(1)}@fq;
	}
	if($opt_trim){ # trim window
		@fq = map{$_->substr_seq($_->qual_window(1))}@fq;
	}
	
	foreach my $SEQ (@fq){
		my $length = length($SEQ->seq);
		# min-length/max-length
		if($opt_min_length){ next if $length < $opt_min_length }; 
		if($opt_max_length){ next if $length > $opt_max_length };
		
		# mask low quality
		$opt_mask && $SEQ->mask_qual_low();

		# OUTPUT
		if($opt_out){
			if($opt_fasta){
				print $ofh sprintf(">%s\n%s\n", substr ($SEQ->seq_head, 1), $SEQ->seq)
			}elsif($opt_transform){
				print $ofh $SEQ->phred_transform()->string();
			}else{
				print $ofh $SEQ->string();
			}
		}
		
		# OUTPUT STATS
		# store length for Nx computation
		push @filtered_L, $length;
		# length stuff
		$filtered_length+=$length;
		$filtered_longest = $length if $length > $filtered_longest;
		$filtered_shortest = $length if (!defined ($filtered_shortest) || $length < $filtered_shortest);
		# base content
		if(@opt_base_content){
			foreach (@opt_base_content){
				$BCs{$_} += $SEQ->base_content($_);
			}
		}
	}
}

$VPB->finish();


=head2 print summary

=cut

#Nx computation
if(@opt_N){
	%filtered_Ns = Nx(total_length => $filtered_length, lengths => [@filtered_L], Nxs => [@opt_N]);
	%total_Ns = Nx(total_length => $total_length, lengths => [@total_L], Nxs => [@opt_N]);
}

$V->hline();
$V->verbose('Input');
$V->verbose(sprintf("%-15s %10d #","Sequences", $total_count));
$V->verbose(sprintf("%-15s %10d bp", "Total", $total_length));
$V->verbose(sprintf("%-15s %10d bp", "Longest", $total_longest));
$V->verbose(sprintf("%-15s %10d bp", "Shortest",$total_shortest));

my @total_Ns;
foreach (sort{$a <=> $b}keys %total_Ns){
	$V->verbose(sprintf("%-15s %10d bp", "N$_", $total_Ns{$_}));
	push @total_Ns, $total_Ns{$_};
}

$V->hline();

unless(keys @filtered_L){
	$V->verbose("No sequences found matching given filter criteria");
	exit(1);
}



$V->verbose("Filtered");
$V->verbose(sprintf("%-15s %10d #","Sequences", scalar @filtered_L));
$V->verbose(sprintf("%-15s %10d bp", "Total", $filtered_length));
$V->verbose(sprintf("%-15s %10d bp", "Longest", $filtered_longest));
$V->verbose(sprintf("%-15s %10d bp", "Shortest", $filtered_shortest));

my @filtered_Ns;
foreach (sort{$a <=> $b}keys %filtered_Ns){
	$V->verbose(sprintf("%-15s %10d bp", "N$_", $filtered_Ns{$_}));
	push @filtered_Ns, $filtered_Ns{$_};
}

# base content
my @BCs;
if(keys %BCs){
	foreach my $k(sort keys %BCs){
		$V->verbose(sprintf("%-15s %10d bp %10.2f %%", "[$k]", $BCs{$k}, (100*$BCs{$k}/$total_length)));
		push @BCs, $BCs{$k};
	}
}


$V->hline();
$V->nline();



if($tsv){
	print $tsv join("\t", scalar @filtered_L, $filtered_length, $filtered_longest, $filtered_shortest, @filtered_Ns, @BCs),"\n";
}



##------------------------------------------------------------------------##

=head1 Methods

=cut

=head2 read_ids

=cut

sub read_ids{
	my @IDS;
	if($opt_ids eq '-'){
		while(<STDIN>){
			push @IDS, split(/[\s,\n]+/, $_);
		}
	}else{
		open(IDS, $opt_ids) || $V->exit("Can't open output ids file: '$opt_ids'");
		while(<IDS>){
			push @IDS, split(/[\s,\n]+/, $_);
		}
		close IDS;
	}
	map{s/^[>@]//}@IDS;
	my %IDS;
	@IDS{@IDS}=map{1}@IDS;
	return %IDS;
}

=head2 read_substrs

Read substr coordinate file and return 

=cut

sub read_substrs{
	my %s;
	open(SUBS, $opt_substr_file) || $V->exit("Can't open output substrs file: '$opt_substr_file'");
	while(<SUBS>){
		chomp();
		next unless $_; # ignore empty lines
		my ($id, @f) = split(/\t/, $_);
		$id =~ s/^[>@]//;
		push @{$s{$id}}, [@f];
	}
	close SUBS;
	return %s;	
}

sub Nx{
	my $p = {
		total_length => undef,
		lengths => undef,
		Nxs => [@opt_N],
		@_
	};
	
	my %Ns;
	my @L = sort{$b <=> $a}@{$p->{lengths}};
	my @ls = map{$p->{total_length} * ($_/100)}@{$p->{Nxs}};
	
	my $lc = 0;
	foreach my $l (@L){
		$lc+= $l;
		if($lc >= $ls[0]){
			shift @ls;
			$Ns{shift @{$p->{Nxs}}} = $l;
			last unless @ls;
		}
	}
	return %Ns;
}	


=head1 AUTHOR

Thomas Hackl S<thomas.hackl@uni-wuerzburg.de>

=cut
